#!/bin/bash

# Redprine
#
# Downloads and caches GitHub PRs. Update the associated Redmine issue of any
# new PRs authored by the owner.

GITHUB_TOKEN=''
GITHUB_USERNAME=''

REDMINE_BASE_URL=''

CACHE_FILE="$HOME/redprine.json"

NEW_PRS=''

function github_owner_repo () {
	local git_remote=$(git remote get-url origin)
	local owner_repo=$(echo "$git_remote" |
		sed -e 's/git@github.com://' \
			-e 's/.git$//')

	echo "$owner_repo"
}

function fetch_pull_requests () {
	local owner_repo=$(github_owner_repo)
	local pull_requests=$(curl \
		--silent \
		--header 'Accept:application/vnd.github.v3+json' \
		--header "Authorization: Bearer ${GITHUB_TOKEN}" \
		--location "https://api.github.com/repos/${owner_repo}/pulls")

	echo $pull_requests
}

# fetch_pull_requests

function cache_my_pull_requests () {
	local pull_requests="$1"

	local my_pull_requests=$(
		printf "%s\n" "$pull_requests" |
		jq '. |
			map({
				html_url,
				number,
				user: .user.login,
				ref: .head.ref,
				created_at
			}) |
			map(
				select(.user == "teddywing")
			)'
	)

	echo $my_pull_requests > "$CACHE_FILE"
}

# branch_heads=$(printf "%s\n" "$pull_requests" |
# 	jq '. | map([.["html_url"], .["head"]["label"]]) | .[] | @tsv' --raw-output)

# jq -C '. | map({ html_url, number, user: .user.login, ref: .head.ref, created_at })' pulls.json
# jq -C '. | map({ html_url, number, user: .user.login, ref: .head.ref, created_at }) | map(select(.user == "teddywing"))' pulls.json

# pull_requests=$(fetch_pull_requests)
# cache_my_pull_requests "$pull_requests"

# function compare_with_cache () {
function new_pull_requests () {
	local pull_requests=$(fetch_pull_requests)

	local my_prs=$(extract_data_from_pull_request_json "$pull_requests")
	# echo "$my_prs"

	local new=$(jq "${my_prs} - ." "$CACHE_FILE")

	echo "$new"
}

# jq '[ { "html_url": "https://github.com/owner/repo/pull/487", "number": 487, "user": "teddywing", "ref": "9999-this-is-a-test", "created_at": "2018-04-16T16:17:52Z" } ] - .' pulls-my.json  #=> []
# jq '[ { "html_url": "https://github.com/owner/repo/pull/487", "number": 487, "user": "teddywing", "ref": "9999-this-is-a-test", "created_at": "2018-04-16T16:17:52Z" } ] - . | length' pulls-my.json  #=> 0

function extract_data_from_pull_request_json () {
	local pull_requests="$1"

	printf "%s\n" "$pull_requests" |
		jq --compact-output '. |
			map({
				html_url,
				number,
				user: .user.login,
				ref: .head.ref,
				created_at
			}) |
			map(
				select(.user == "teddywing")
			)'
}

function extract_redmine_issue_numbers_from_pull_request () {
	local pull_requests="$1"

	local branch_names=$(
		printf "%s\n" "$pull_requests" |
		jq --raw-output 'map(.ref) | .[] | @text'
	)

	# Issue IDs are 4-digit prefixes to branch names.
	local issue_ids=$(
		echo "$branch_names" |
		perl -ne '/^(\d{4})-/ && print "$1\n"'
	)

	echo "$issue_ids"
}

# jq --raw-output 'map(.ref) | .[] | @text' pulls-my.json
# jq --raw-output 'map(.ref) | .[] | @text' pulls-my.json | perl -ne '/^(\d{4})-/ && print "$1\n"'

# jq --raw-output '. | map({ html_url, number, user: .user.login, ref: .head.ref, created_at }) | map(select(.user == "teddywing")) | map([.ref, .html_url]) | .[] | @tsv' pulls.json

function branches_and_pull_request_urls () {
	local pull_requests="$1"

	printf "%s\n" "$pull_requests" |
		jq --raw-output 'map([.ref, .html_url]) | .[] | @tsv'
}

function issue_numbers_and_pull_request_urls () {
	local pull_requests="$1"

	local branch_and_urls=$(branches_and_pull_request_urls "$pull_requests")

	echo "$branch_and_urls" |
		perl -ne '/^(\d{4})-[^\t]*\t(.*)/ && print "$1\t$2\n"'
}

# jq --raw-output '. | map({ html_url, number, user: .user.login, ref: .head.ref, created_at }) | map(select(.user == "teddywing")) | map([.ref, .html_url]) | .[] | @tsv' pulls.json | perl -ne '/^(\d{4})-[^\t]*\t(.*)/ && print "$1\t$2\n"'

# Updates the "Done", "Status", and "Pull Request" fields for each given issue.
function update_redmine_statuses () {
	local issue_ids_and_urls="$1"

	if [ ! -z "$issue_ids_and_urls" ]; then
		for id_and_url in "$issue_ids_and_urls"; do
			update_redmine_status "$id_and_url"
		done
	fi
}

function update_redmine_status () {
	local issue_pr="$1"

	local issue_id=$(
		echo "$issue_pr" |
		cut -d '	' -f 1 -
	)

	local pull_request_link=$(
		echo "$issue_pr" |
		cut -d '	' -f 2 -
	)

	# status_id=14  # Review
	# done_ratio=100
	# issue[custom_field_values][11]  # Pull Request
	local json="{
		\"issue\": {
			\"status_id\": 14,
			\"done_ratio\": 100,
			\"custom_field_values\": {
				\"11\": \"$pull_request_link\"
			}
		}
	}"

	# echo "$json"
	# echo  "${REDMINE_BASE_URL}/issues/${issue_id}.json"
	curl \
		--verbose \
		--header 'Content-Type: application/json' \
		--request PUT \
		--data "$json" \
		--location "${REDMINE_BASE_URL}/issues/${issue_id}.json"

	# Output an error message if the request fails
	# https://superuser.com/questions/272265/getting-curl-to-output-http-status-code/442395#442395
	# curl -s -o /dev/null -w "%{http_code}" http://www.example.org/
	# curl -s -o /dev/null -I -w "%{http_code}" http://www.example.org/
}

function update_cache_with_new_pulls () {
	jq "${NEW_PRS} + ." "$CACHE_FILE" > "${CACHE_FILE}.new"
	mv "${CACHE_FILE}.new" "$CACHE_FILE"
}



# pull_requests=$(fetch_pull_requests)
# cache_my_pull_requests "$pull_requests"
pr_json=$(new_pull_requests)
NEW_PRS="$pr_json"
issue_prs=$(issue_numbers_and_pull_request_urls "$pr_json")

update_redmine_statuses "$issue_prs"
update_cache_with_new_pulls
