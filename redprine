#!/bin/bash

# Redprine
#
# Downloads and caches GitHub PRs. Update the associated Redmine issue of any
# new PRs authored by the owner.

GITHUB_TOKEN=''
GITHUB_USERNAME=''

REDMINE_BASE_URL=''
REDMINE_TOKEN=''

CACHE_FILE="$HOME/redprine.json"

function github_owner_repo () {
	local git_remote=$(git remote get-url origin)
	local owner_repo=$(echo "$git_remote" |
		sed -e 's/git@github.com://' \
			-e 's/.git$//')

	echo "$owner_repo"
}

# Get a list of open pull requests from the GitHub API.
function fetch_pull_requests () {
	local owner_repo=$(github_owner_repo)
	local pull_requests=$(curl \
		--silent \
		--header 'Accept:application/vnd.github.v3+json' \
		--header "Authorization: Bearer ${GITHUB_TOKEN}" \
		--location "https://api.github.com/repos/${owner_repo}/pulls")

	echo "$pull_requests"
}

# Stores pull requests to the cache file.
function cache_my_pull_requests () {
	local pull_requests="$1"

	local my_pull_requests=$(
		printf "%s\n" "$pull_requests" |
		jq '. |
			map({
				html_url,
				number,
				user: .user.login,
				ref: .head.ref,
				created_at
			}) |
			map(
				select(.user == "teddywing")
			)'
	)

	echo "$my_pull_requests" > "$CACHE_FILE"
}

# Fetches the latest pull requests from GitHub and gets a list of those that
# aren't in our cache file.
function new_pull_requests () {
	local pull_requests=$(fetch_pull_requests)

	local my_prs=$(extract_data_from_pull_request_json "$pull_requests")

	local new=$(jq "${my_prs} - ." "$CACHE_FILE")

	echo "$new"
}

# Filters JSON pull requests from the GitHub API including only those for the
# requested username. The result is a JSON array of hashes containing only a
# few relevant pull request fields.
function extract_data_from_pull_request_json () {
	local pull_requests="$1"

	printf "%s\n" "$pull_requests" |
		jq --compact-output '. |
			map({
				html_url,
				number,
				user: .user.login,
				ref: .head.ref,
				created_at
			}) |
			map(
				select(.user == "teddywing")
			)'
}

function extract_redmine_issue_numbers_from_pull_request () {
	local pull_requests="$1"

	local branch_names=$(
		printf "%s\n" "$pull_requests" |
		jq --raw-output 'map(.ref) | .[] | @text'
	)

	# Issue IDs are 4-digit prefixes to branch names.
	local issue_ids=$(
		echo "$branch_names" |
		perl -ne '/^(\d{4})-/ && print "$1\n"'
	)

	echo "$issue_ids"
}

# Produces a tab-separated list of branch names and pull request URLs from our
# extracted JSON.
function branches_and_pull_request_urls () {
	local pull_requests="$1"

	printf "%s\n" "$pull_requests" |
		jq --raw-output 'map([.ref, .html_url]) | .[] | @tsv'
}

# Turns a tab-separated list of branch names and pull request URLs into a
# tab-separated list of Redmine issue numbers and pull request URLs. Gets the
# issue number as a four-digit prefix of the branch name.
function issue_numbers_and_pull_request_urls () {
	local pull_requests="$1"

	local branch_and_urls=$(branches_and_pull_request_urls "$pull_requests")

	echo "$branch_and_urls" |
		perl -ne '/^(\d{4})-[^\t]*\t(.*)/ && print "$1\t$2\n"'
}

# Updates fields for each given issue.
function update_redmine_statuses () {
	local issue_ids_and_urls="$1"

	if [ ! -z "$issue_ids_and_urls" ]; then
		for id_and_url in "$issue_ids_and_urls"; do
			update_redmine_status "$id_and_url"
		done
	fi
}

# Given a tab-separated Redmine issue number and GitHub pull request URL, will
# update fields on the given issue.
function update_redmine_status () {
	local issue_pr="$1"

	local issue_id=$(
		echo "$issue_pr" |
		cut -d '	' -f 1 -
	)

	local pull_request_link=$(
		echo "$issue_pr" |
		cut -d '	' -f 2 -
	)

	# status_id=14  # Review
	# done_ratio=100
	# issue[custom_field_values][11]  # Pull Request
	local json="{
		\"issue\": {
			\"status_id\": 14,
			\"done_ratio\": 100,
			\"custom_field_values\": {
				\"11\": \"$pull_request_link\"
			}
		}
	}"

	curl \
		--verbose \
		--header 'Content-Type: application/json' \
		--header "X-Redmine-API-Key: $REDMINE_TOKEN" \
		--request PUT \
		--data "$json" \
		--location "${REDMINE_BASE_URL}/issues/${issue_id}.json"

	# Output an error message if the request fails
	# https://superuser.com/questions/272265/getting-curl-to-output-http-status-code/442395#442395
	# curl -s -o /dev/null -w "%{http_code}" http://www.example.org/
	# curl -s -o /dev/null -I -w "%{http_code}" http://www.example.org/
}

# Updates the cache file appending new pull requests in our JSON format.
function update_cache_with_new_pulls () {
	local new_pull_requests="$1"

	jq "$new_pull_requests" "$CACHE_FILE" > "${CACHE_FILE}.new"
	mv "${CACHE_FILE}.new" "$CACHE_FILE"
}



pr_json=$(new_pull_requests)
issue_prs=$(issue_numbers_and_pull_request_urls "$pr_json")

update_redmine_statuses "$issue_prs"
update_cache_with_new_pulls "$pr_json"
